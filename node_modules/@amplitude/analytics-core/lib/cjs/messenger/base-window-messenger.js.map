{"version":3,"file":"base-window-messenger.js","sourceRoot":"","sources":["../../../src/messenger/base-window-messenger.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { ILogger } from '../logger';\nimport { Messenger } from '../types/element-interactions';\nimport { getGlobalScope } from '../global-scope';\nimport { AMPLITUDE_ORIGIN } from './constants';\nimport { asyncLoadScript, generateUniqueId } from './utils';\n\ntype MessageRequest = {\n  id: string;\n  action: string;\n  args: Record<string, any>;\n};\n\ntype MessageResponse = {\n  id: string;\n  action: string;\n  responseData: any;\n};\n\nexport type ActionHandler = (data: any) => void;\n\n/**\n * Brand key used to identify BaseWindowMessenger instances across bundle boundaries.\n */\nconst MESSENGER_BRAND = '__AMPLITUDE_MESSENGER_INSTANCE__' as const;\n\n/** Global scope key where the singleton messenger is stored. */\nconst MESSENGER_GLOBAL_KEY = '__AMPLITUDE_MESSENGER__';\n\n/**\n * BaseWindowMessenger provides generic cross-window communication via postMessage.\n * Singleton access via getOrCreateWindowMessenger() to prevent duplicate instances\n */\nclass BaseWindowMessenger implements Messenger {\n  /** Brand property for cross-bundle instanceof checks. */\n  readonly [MESSENGER_BRAND] = true;\n\n  endpoint: string;\n  logger?: ILogger;\n  private isSetup = false;\n  private messageHandler: ((event: MessageEvent) => void) | null = null;\n  requestCallbacks: {\n    [id: string]: {\n      resolve: (data: any) => void;\n      reject: (data: any) => void;\n    };\n  } = {};\n  private actionHandlers = new Map<string, ActionHandler>();\n\n  /**\n   * Messages received for actions that had no registered handler yet.\n   * Drained automatically when the corresponding handler is registered via\n   * registerActionHandler(), solving startup race conditions between\n   * independently-initialized plugins.\n   */\n  private pendingMessages = new Map<string, any[]>();\n\n  /**\n   * Tracks in-flight and completed script loads by URL.\n   * Using a map, this prevents duplicate loads before the first resolves.\n   */\n  private scriptLoadPromises = new Map<string, Promise<void>>();\n\n  constructor({ origin = AMPLITUDE_ORIGIN }: { origin?: string } = {}) {\n    this.endpoint = origin;\n  }\n\n  /**\n   * Send a message to the parent window (window.opener).\n   */\n  notify(message: { action: string; data?: any } | MessageRequest) {\n    this.logger?.debug?.('Message sent: ', JSON.stringify(message));\n    (window.opener as WindowProxy)?.postMessage?.(message, this.endpoint);\n  }\n\n  /**\n   * Send an async request to the parent window with a unique ID.\n   * Returns a Promise that resolves when the parent responds.\n   */\n  public sendRequest(action: string, args: Record<string, any>, options = { timeout: 15_000 }): Promise<any> {\n    const id = generateUniqueId();\n    const request: MessageRequest = { id, action, args };\n\n    const promise = new Promise((resolve, reject) => {\n      this.requestCallbacks[id] = { resolve, reject };\n\n      this.notify(request);\n\n      if (options.timeout > 0) {\n        setTimeout(() => {\n          reject(new Error(`${action} timed out (id: ${id})`));\n          delete this.requestCallbacks[id];\n        }, options.timeout);\n      }\n    });\n\n    return promise;\n  }\n\n  /**\n   * Handle a response to a previous request by resolving its Promise.\n   */\n  private handleResponse(response: MessageResponse) {\n    if (!this.requestCallbacks[response.id]) {\n      this.logger?.warn(`No callback found for request id: ${response.id}`);\n      return;\n    }\n\n    this.requestCallbacks[response.id].resolve(response.responseData);\n    delete this.requestCallbacks[response.id];\n  }\n\n  /**\n   * Register a handler for a specific action type.\n   * Logs a warning if overwriting an existing handler.\n   */\n  registerActionHandler(action: string, handler: ActionHandler) {\n    if (this.actionHandlers.has(action)) {\n      this.logger?.warn?.(`Overwriting existing action handler for: ${action}`);\n    }\n    this.actionHandlers.set(action, handler);\n\n    // Replay any messages that arrived before this handler was registered\n    const queued = this.pendingMessages.get(action);\n    if (queued) {\n      this.pendingMessages.delete(action);\n      for (const data of queued) {\n        handler(data);\n      }\n    }\n  }\n\n  /**\n   * Load a script once, deduplicating by URL.\n   * Safe against concurrent calls — the second call awaits the first's in-flight Promise\n   * rather than triggering a duplicate load.\n   */\n  async loadScriptOnce(url: string): Promise<void> {\n    const existing = this.scriptLoadPromises.get(url);\n    if (existing) {\n      return existing;\n    }\n\n    const loadPromise = asyncLoadScript(url).then(() => {\n      // Resolve to void\n    });\n    this.scriptLoadPromises.set(url, loadPromise);\n\n    try {\n      await loadPromise;\n    } catch (error) {\n      // Remove failed loads so they can be retried\n      this.scriptLoadPromises.delete(url);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up the message listener. Idempotent — safe to call multiple times.\n   * Subclasses should call super.setup() and then register their own action handlers.\n   */\n  setup({ logger, endpoint }: { logger?: ILogger; endpoint?: string } = {}) {\n    if (logger) {\n      this.logger = logger;\n    }\n\n    // If endpoint is customized, don't override a previously customized endpoint.\n    if (endpoint && this.endpoint === AMPLITUDE_ORIGIN) {\n      this.endpoint = endpoint;\n    }\n\n    // Only attach the message listener once\n    if (this.isSetup) {\n      return;\n    }\n    this.isSetup = true;\n\n    this.logger?.debug?.('Setting up messenger');\n\n    // Attach Event Listener to listen for messages from the parent window\n    this.messageHandler = (event: MessageEvent) => {\n      this.logger?.debug?.('Message received: ', JSON.stringify(event));\n\n      // Only accept messages from the specified origin\n      if (this.endpoint !== event.origin) {\n        return;\n      }\n\n      const eventData = event.data as { action?: string; id?: string; data?: any; responseData?: any };\n      const action = eventData?.action;\n\n      // Ignore messages without action\n      if (!action) {\n        return;\n      }\n\n      // If id exists, handle responses to previous requests\n      if ('id' in eventData && eventData.id) {\n        this.logger?.debug?.('Received Response to previous request: ', JSON.stringify(event));\n        this.handleResponse(eventData as MessageResponse);\n      } else {\n        if (action === 'ping') {\n          this.notify({ action: 'pong' });\n          return;\n        }\n\n        // Dispatch to registered action handlers, or buffer for late registration\n        const handler = this.actionHandlers.get(action);\n        if (handler) {\n          handler(eventData.data);\n        } else {\n          const queue = this.pendingMessages.get(action) ?? [];\n          queue.push(eventData.data);\n          this.pendingMessages.set(action, queue);\n        }\n      }\n    };\n    window.addEventListener('message', this.messageHandler);\n\n    this.notify({ action: 'page-loaded' });\n  }\n\n  /**\n   * Tear down the messenger: remove the message listener, clear all state.\n   */\n  destroy() {\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n      this.messageHandler = null;\n    }\n    this.isSetup = false;\n    this.actionHandlers.clear();\n    this.pendingMessages.clear();\n    this.requestCallbacks = {};\n    this.scriptLoadPromises.clear();\n\n    // Remove from global scope if this is the singleton\n    const globalScope = getGlobalScope() as Record<string, unknown> | undefined;\n    if (globalScope?.[MESSENGER_GLOBAL_KEY] === this) {\n      delete globalScope[MESSENGER_GLOBAL_KEY];\n    }\n  }\n}\n\n/**\n * Type guard: checks whether a value is a BaseWindowMessenger instance.\n */\nfunction isWindowMessenger(value: unknown): value is BaseWindowMessenger {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    MESSENGER_BRAND in value &&\n    (value as Record<string, unknown>)[MESSENGER_BRAND] === true\n  );\n}\n\n/**\n * Get or create a singleton BaseWindowMessenger instance.\n * Ensures only one messenger (and one message listener) exists per page,\n * preventing duplicate script loads and double notifications.\n *\n * The singleton is stored on globalScope under the same MESSENGER_KEY.\n * The branded property check verifies the stored value is actually a messenger.\n */\nexport function getOrCreateWindowMessenger(options?: { origin?: string }): BaseWindowMessenger {\n  const globalScope = getGlobalScope() as Record<string, unknown> | undefined;\n\n  const existing = globalScope?.[MESSENGER_GLOBAL_KEY];\n  if (isWindowMessenger(existing)) {\n    return existing;\n  }\n\n  const messenger = new BaseWindowMessenger(options);\n  if (globalScope) {\n    globalScope[MESSENGER_GLOBAL_KEY] = messenger;\n  }\n  return messenger;\n}\n\nexport type { BaseWindowMessenger };\n"]}